#!/usr/bin/env python
"""
environdata.py

A WeeWX driver for the Environdata Weather Mate 3000.

Copyright (C) 2020-2021 Gary Roderick                   gjroderick<at>gmail.com

This program is free software: you can redistribute it and/or modify it under
the terms of the GNU General Public License as published by the Free Software
Foundation, either version 3 of the License, or (at your option) any later
version.

This program is distributed in the hope that it will be useful, but WITHOUT ANY
WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
PARTICULAR PURPOSE.  See the GNU General Public License for more details.

You should have received a copy of the GNU General Public License along with
this program.  If not, see https://www.gnu.org/licenses/.

Version: 0.1.0a4                                    Date: ? November 2021

Revision History
    ? November 2021         v0.1.0
        -   initial release

To use this driver:

1.  If installing on a fresh WeeWX installation install WeeWX and configure it
to use the 'simulator'. Refer to https://weewx.com/docs/usersguide.htm#installing

2.  put this file in $BIN_ROOT/user ( for setup.py installs this
is /home/weewx/bin/user, for package installs this is /usr/share/weewx/user)

3.  add the following stanza to weewx.conf replacing w.x.y.z with the IP
address of the station:

    [Environdata]
        # This section is for the Environdata

        # The driver file
        driver = user.environdata

        # station IP address
        ip_address = w.x.y.z

4.  Confirm that WeeWX is set to use software record generation
(refer https://weewx.com/docs/usersguide.htm#record_generation). In weewx.conf
under [StdArchive] ensure the record_generation setting is set to software:

        [StdArchive]
            ....
            record_generation = software

    If record_generation is set to hardware change it to software.

5.  Test the Environdata driver by running the driver file directly using the
--test-driver command line option:

    $ PYTHONPATH=/home/weewx/bin python -m user.environdata --test-driver

    for setup.py installs or for package installs use:

    $ PYTHONPATH=/usr/share/weewx python -m user.environdata --test-driver

    Note: Depending on your system/installation the above command may need to be
          prefixed with sudo.

    Note: Whilst the driver may be run independently of WeeWX the driver still
          requires WeeWX and it's dependencies be installed. Consequently, if
          WeeWX 4.0.0 or later is installed the driver must be run under the
          same Python version as WeeWX uses. This means that on some systems
          'python' in the above commands may need to be changed to 'python2' or
          'python3'.

    Note: If necessary you can specify the station IP address using the
          --ip-address command line option. Refer to the Environdata driver
          help using --help for further information.

    You should observe loop packets being emitted on a regular basis. Once
    finished press ctrl-c to exit.

    Note: You will only see loop packets and not archive records when running
          the driver directly. This is because you are seeing output directly
          from the driver and not WeeWX.

6.  Configure the driver:

    $ wee_config --reconfigure --driver=user.environdata

    Note: Depending on your system/installation the above command may need to
          be prefixed with sudo.

    Note: Depending on your WeeWX installation wee_config may need to be
          prefixed with the path to wee_config.

7.  You may chose to run WeeWX directly (refer
https://weewx.com/docs/usersguide.htm#Running_directly) to observe the loop
packets and archive records being generated by WeeWX.

8.  Once satisfied that the Environdata driver is operating correctly you can
start the WeeWX daemon:

    $ sudo /etc/init.d/weewx start

    or

    $ sudo service weewx start

    or

    $ sudo systemctl start weewx
"""

import configobj
import telnetlib
import time

# Python 2/3 compatibility shims
import six
from six.moves import StringIO

# WeeWX imports
import weecfg
import weewx
import weeutil.weeutil
import weewx.drivers
import weewx.units

# import/setup logging, WeeWX v3 is syslog based but WeeWX v4 is logging based,
# try v4 logging and if it fails use v3 logging
try:
    # WeeWX4 logging
    import logging
    from weeutil.logger import log_traceback

    log = logging.getLogger(__name__)

    def logdbg(msg):
        log.debug(msg)

    def loginf(msg):
        log.info(msg)

    def logerr(msg):
        log.error(msg)

    # log_traceback() generates the same output but the signature and code is
    # different between v3 and v4. We only need log_traceback at the log.error
    # level so define a suitable wrapper function.
    def log_traceback_critical(prefix=''):
        log_traceback(log.critical, prefix=prefix)

    def log_traceback_error(prefix=''):
        log_traceback(log.error, prefix=prefix)

    def log_traceback_debug(prefix=''):
        log_traceback(log.debug, prefix=prefix)

except ImportError:
    # WeeWX legacy (v3) logging via syslog
    import syslog
    from weeutil.weeutil import log_traceback

    def logmsg(level, msg):
        syslog.syslog(level, 'environdata: %s' % msg)

    def logdbg(msg):
        logmsg(syslog.LOG_DEBUG, msg)

    def loginf(msg):
        logmsg(syslog.LOG_INFO, msg)

    def logerr(msg):
        logmsg(syslog.LOG_ERR, msg)

    # log_traceback() generates the same output but the signature and code is
    # different between v3 and v4. We only need log_traceback at the log.error
    # level so define a suitable wrapper function.
    def log_traceback_critical(prefix=''):
        log_traceback(prefix=prefix, loglevel=syslog.LOG_CRIT)

    def log_traceback_error(prefix=''):
        log_traceback(prefix=prefix, loglevel=syslog.LOG_ERR)

    def log_traceback_debug(prefix=''):
        log_traceback(prefix=prefix, loglevel=syslog.LOG_DEBUG)

DRIVER_NAME = 'Environdata'
DRIVER_VERSION = '0.1.0a3'

DEFAULT_PORT = 10001
DEFAULT_POLL_INTERVAL = 20
DEFAULT_MAX_RETRIES = 3
DEFAULT_PACKET_TYPE = 'r1'


# ============================================================================
#               Environdata Loader/Configurator/Editor methods
# ============================================================================

def loader(config_dict, engine):
    return EnvirondataDriver(**config_dict[DRIVER_NAME])


def configurator_loader(config_dict):  # @UnusedVariable

    pass
    # return EnvirondataConfigurator()


def confeditor_loader():
    return EnvirondataConfEditor()


# ============================================================================
#                         class EnvirondataConfEditor
# ============================================================================

class EnvirondataConfEditor(weewx.drivers.AbstractConfEditor):
    # define our config as a multiline string so we can preserve comments
    accum_config = """
    [Accumulator]
        # Start Environdata driver extractors
        [[batteryStatus1]]
            extractor = last
        [[load_current]]
            extractor = last
        [[solar_voltage]]
            extractor = last
        [[charge_current]]
            extractor = last
        # End Environdata driver extractors
    """

    @property
    def default_stanza(self):
        return """
    [Environdata]
        # This section is for the Environdata driver.

        # the driver to use
        driver = user.environdata

        # station IP address
        ip_address = w.x.y.z        

        # station telnet port
        port = %d        

        # how often to poll the station
        poll_interval = %d
    """ % (DEFAULT_PORT, DEFAULT_POLL_INTERVAL)

    def get_conf(self, orig_stanza=None):
        """Given a configuration stanza, return a possibly modified copy
        that will work with the current version of the device driver.

        The default behavior is to return the original stanza, unmodified.

        Derived classes should override this if they need to modify previous
        configuration options or warn about deprecated or harmful options.

        The return value should be a long string. See default_stanza above
        for an example string stanza."""
        return self.default_stanza if orig_stanza is None else orig_stanza

    def prompt_for_settings(self):
        """Prompt for settings required for proper operation of this driver.

        Returns a dict of setting, value key pairs for settings to be included
        in the driver stanza. The _prompt() method may be used to prompt the
        user for input with a default.
        """

        # obtain IP address
        print()
        print("Specify Environdata station IP address, for example: 192.168.1.100")
        ip_address = self._prompt('IP address',
                                  dflt=self.existing_options.get('ip_address'))
        # obtain port number
        print()
        print("Specify Environdata station telnet, for example: 10001")
        port = self._prompt('port', dflt=self.existing_options.get('port', DEFAULT_PORT))
        # obtain poll interval
        print()
        print("Specify how often to poll the station in seconds")
        poll_interval = self._prompt('Poll interval',
                                     dflt=self.existing_options.get('poll_interval',
                                                                    DEFAULT_POLL_INTERVAL))
        return {'ip_address': ip_address,
                'port': port,
                'poll_interval': poll_interval
                }

    @staticmethod
    def modify_config(config_dict):

        import weecfg

        # set loop_on_init
        loop_on_init_config = """loop_on_init = %d"""
        dflt = config_dict.get('loop_on_init', '1')
        label = """The Environdata driver requires a network connection to the 
station. Consequently, the absence of a network connection when 
WeeWX starts will cause WeeWX to exit and such a situation can 
occur on system startup. The 'loop_on_init' setting can be used
to mitigate such problems by having WeeWX retry startup 
indefinitely. Set to '0' to attempt startup once only or '1' to 
attempt startup indefinitely."""
        print()
        loop_on_init = int(weecfg.prompt_with_options(label, dflt, ['0', '1']))
        loop_on_init_dict = configobj.ConfigObj(StringIO(loop_on_init_config % (loop_on_init, )))
        config_dict.merge(loop_on_init_dict)
        if len(config_dict.comments['loop_on_init']) == 0:
            config_dict.comments['loop_on_init'] = ['', '# Whether to try indefinitely to load the driver']
        print()

        # set record generation to software
        print("""Setting record_generation to software.""")
        config_dict['StdArchive']['record_generation'] = 'software'
        print()

        # set the accumulator extractor functions
        print("""Setting accumulator extractor functions.""")
        # construct our default accumulator config dict
        accum_config_dict = configobj.ConfigObj(StringIO(EnvirondataConfEditor.accum_config))
        # merge the existing config dict into our default accumulator config
        # dict so that we keep any changes made to [Accumulator] by the user
        accum_config_dict.merge(config_dict)
        # now make our updated accumulator config the config dict
        config_dict = configobj.ConfigObj(accum_config_dict)

        # we don't need weecfg any more so remove it from memory
        del weecfg
        print()


# ============================================================================
#                          class EnvirondataDriver
# ============================================================================

class EnvirondataDriver(weewx.drivers.AbstractDevice):
    """Driver for the Environdata Weather Mate 3000."""

    parser_map = {'r1': 'parse_r1_data'}

    r1_map = {
        'wind_speed': {'field': 'WS',
                       'group': 'group_speed',
                       'unit': 'km_per_hour',
                       'conv_fn': lambda x: x
                       },
        'wind_direction': {'field': 'WD',
                           'group': 'group_direction',
                           'unit': 'degree_compass',
                           'conv_fn': lambda x: x
                           },
        'relative_humidity': {'field': 'RH',
                              'group': 'group_percent',
                              'unit': 'percent',
                              'conv_fn': lambda x: x
                              },
        'air_temperature': {'field': 'AT',
                            'group': 'group_temperature',
                            'unit': 'degree_C',
                            'conv_fn': lambda x: x
                            },
        'barometric_pressure': {'field': 'BP',
                                'group': 'group_pressure',
                                'unit': 'hPa',
                                'conv_fn': lambda x: x
                                },
        'battery_voltage': {'field': 'BV',
                            'group': 'group_volt',
                            'unit': 'volt',
                            'conv_fn': lambda x: x
                            },
        'load_current': {'field': 'LC',
                         'group': 'group_amp',
                         'unit': 'amp',
                         'conv_fn': lambda x: x/1000
                         },
        'solar_voltage': {'field': 'SV',
                          'group': 'group_volt',
                          'unit': 'volt',
                          'conv_fn': lambda x: x
                          },
        'charge_current': {'field': 'CC',
                           'group': 'group_amp',
                           'unit': 'amp',
                           'conv_fn': lambda x: x/1000
                           },
        'peak_wind_gust': {'field': 'PW',
                           'group': 'group_speed',
                           'unit': 'km_per_hour',
                           'conv_fn': lambda x: x
                           },
        'instantaneous_wind_speed': {'field': 'IW',
                                     'group': 'group_speed',
                                     'unit': 'km_per_hour',
                                     'conv_fn': lambda x: x
                                     },
        'instantaneous_wind_direction': {'field': 'IW',
                                         'group': 'group_direction',
                                         'unit': 'degree_compass',
                                         'conv_fn': lambda x: x
                                         },
        'rain_since_9am': {'field': 'RS',
                           'group': 'group_rain',
                           'unit': 'mm',
                           'conv_fn': lambda x: x
                           },
        'communications': {'field': 'Co',
                           'group': 'group_elapsed',
                           'unit': 'minute',
                           'conv_fn': lambda x: x
                           }
    }
    default_field_map = {'avg_wind_speed': 'wind_speed',
                         'avg_wind_direction': 'wind_direction',
                         'outHumidity': 'relative_humidity',
                         'outTemp': 'air_temperature',
                         'barometer': 'barometric_pressure',
                         'batteryStatus1': 'battery_voltage',
                         'load_current': 'load_current',
                         'solar_voltage': 'solar_voltage',
                         'charge_current': 'charge_current',
                         'windGust': 'peak_wind_gust',
                         'windSpeed': 'instantaneous_wind_speed',
                         'windDir': 'instantaneous_wind_direction',
                         'rain_9am': 'rain_since_9am',
                         'communications': 'communications'
                         }

    prompt = b'>'
    cmd_terminator = '\r'

    def __init__(self, **stn_dict):
        """Initialise an Environdata driver object."""

        # log our version number
        loginf('driver version is %s' % DRIVER_VERSION)

        # obtain the IP address to use
        self.ip_address = stn_dict.get('ip_address')
        # obtain the port number to use
        self.port = weeutil.weeutil.to_int(stn_dict.get('port', DEFAULT_PORT))
        # obtain the poll interval to use
        self.poll_interval = weeutil.weeutil.to_int(stn_dict.get('poll_interval',
                                                                 DEFAULT_POLL_INTERVAL))
        # obtain the number of retries to use when contacting the station
        # before giving up
        self.max_retries = weeutil.weeutil.to_int(stn_dict.get('max_retries',
                                                               DEFAULT_MAX_RETRIES))
        # which data packet type are we obtaining from the station
        self.packet_type = stn_dict.get('packet_type', DEFAULT_PACKET_TYPE)

        # get the WeeWX field map to use
        self.field_map = EnvirondataDriver.default_field_map

        # now log some of our settings
        loginf('IP address is %s:%d' % (self.ip_address,
                                        self.port))
        loginf('poll interval is %d seconds' % self.poll_interval)
        logdbg('max retries is %d' % (self.max_retries, ))
        loginf("packet type '%s' will be used" % self.packet_type)

    @property
    def hardware_name(self):
        """Return the hardware model."""

        return DRIVER_NAME

    def closePort(self):
        """Close down the driver port."""

        # so far we have nothing to do
        pass

    def genLoopPackets(self):
        """Generate loop like packets of data.

        Steps to generate a loop packet:

        1. read the raw data from the station
        2. parse the raw data
        3. convert the parsed data to WeeWX Metric units
        4. map the converted data to WeeWX loop packet fields
        5. construct the loop packet
        6. yield the loop packet
        7. sleep until the next loop packet is due
        """

        while True:
            # create a loop packet dict and initialise with dateTime and
            # usUnits
            packet = {'dateTime': int(time.time() + 0.5),
                      'usUnits': weewx.METRIC}
            # get raw data from the station
            raw_data = self.read_data()
            if weewx.debug >= 2:
                loginf("raw data=%s" % (raw_data,))
            # parse the raw data
            # first get the parser method to use
            parser_fn = EnvirondataDriver.parser_map.get(self.packet_type)
            if parser_fn is not None:
                parsed_data = getattr(self, parser_fn)(raw_data)
            else:
                parsed_data = None
            if weewx.debug >= 3:
                loginf("parsed data=%s" % (parsed_data,))
            # Some Environdata parsed raw data fields need unit conversion so
            # the resulting loop packet will meet WeeWX unit system
            # requirements. Since this is a driver we are free to choose the
            # unit system to be used, in this case we have chosen Metric.
            converted_data = self.convert_data(parsed_data)
            if weewx.debug >= 3:
                loginf("converted data=%s" % (parsed_data,))
            mapped_data = self.map_data(converted_data)
            if weewx.debug >= 3:
                loginf("mapped data=%s" % (mapped_data,))
            # if we have converted data use it up update our empty packet
            if mapped_data is not None:
                packet.update(mapped_data)
            if weewx.debug >= 2:
                loginf("packet=%s" % (packet,))
            # yield the packet
            yield packet
            # now sleep until the next poll
            time.sleep(self.poll_interval)

    def read_data(self):
        """Read raw data from the station"""

        with telnetlib.Telnet(self.ip_address, self.port) as tn:
            tn.read_until(EnvirondataDriver.prompt, timeout=5)
            # ask for r1 data
            tn.write(six.ensure_binary(''.join([self.packet_type,
                                                EnvirondataDriver.cmd_terminator])))
            # read the response
            raw_data = tn.read_until(EnvirondataDriver.prompt, timeout=10).decode('ascii')
        # return the raw data
        return raw_data

    def parse_r1_data(self, raw_data):
        """Parse raw data from the station.

        Our raw data will contain at least four lines similar to:
        r1
        WS=   ,WD=   ,RH=   ,AT=   ,BP=   ,BV=   ,LC=   ,SV=   ,CC=   ,PW=   ,IW=   ,IW=   ,RS=   ,Co=
        +000005.15,+000112.24,+000060.67,+000022.80,+001015.22,+000012.47,+000042.55,+000013.02,+000203.09,+000007.00,+000005.00,+000133.33,+000000.00,+000001.00
        km/h  ,Degs  ,%     ,DegC  ,hPa   ,V     ,mA    ,V     ,mA    ,km/h  ,km/h  ,Degs  ,mm    ,Mins

        The first line contains the command code used to obtain the data
        The second line consists of comma separated abbreviated field/sensor names.
        The third line consists of comma separated observation values.
        The fourth line consists of comma separated unit abbreviations.

        First the data is parsed and the field names, values and units are
        extracted. This data is then mapped to a dict keyed by self evident
        Environdata field names. Fields using units not supportd by WeeWX are
        converted to a supported unit.
        """

        # do we have any data
        if raw_data is not None:
            # our data of interest is spread over lines two to four, so split it into individual lines
            lines = raw_data.splitlines()
            # do we have four or more lines
            if len(lines) >= 4:
                #  we have four or more lines, so we might have some data to work
                #  with
                # create an empty dict to hold our results
                result = {}
                # field names/codes are in the second line, obtain a raw list of
                # fields by splitting on the comma
                _fields = lines[1].split(',')
                # tidy up our field/code names by stripping off any spaces and the
                # equal sign
                fields = [f.strip('= ') for f in _fields]
                # data is in the third line, obtain a list of data points by
                # splitting on the comma
                data = lines[2].split(',')
                # units are on the fourth line, obtain a list of units by splitting
                # on the comma
                _units = lines[3].split(',')
                # tidy up our unit codes by stripping off any spaces
                units = [u.strip() for u in _units]
                # now zip our three lists together, this will give us a list of
                # three way tuples of the format (field code, data, unit code)
                data_list = list(zip(fields, data, units))
                # now iterate over our data list, extracting data and mapping as
                # per our field map
                for element in data_list:
                    # get the Environdata field name from the r1 map
                    e_field = self.get_r1_e_field(element)
                    # do we have a field name
                    if e_field is not None:
                        # we have an Environdata field name, convert our data
                        # (it is a string) to a float but wrap in a try..except
                        # in case we strike an exception
                        try:
                            val = float(element[1])
                        except (ValueError, TypeError):
                            # Could not convert to a float, most likely because
                            # the data was corrupted. Skip this data point.
                            continue
                        else:
                            # we have a float, now apply the applicable
                            # conversion function from the r1 map
                            result[e_field] = EnvirondataDriver.r1_map[e_field].get('conv_fn', lambda x: x)(val)
                # return our dict of parsed data
                return result
            else:
                # we cannot parse this data so return None
                return None
        else:
            # we have no data so return None
            return None

    def map_data(self, parsed_data):
        """Map parsed data to WeeWX field names."""

        if parsed_data is not None:
            result = {}
            for w_field, e_field in six.iteritems(self.field_map):
                if e_field in parsed_data:
                    result[w_field] = parsed_data[e_field]
            return result
        else:
            return None

    @staticmethod
    def convert_data(parsed_data):
        """Take a packet of parsed data and convert to Metric units.

        Most Environdata Weather Mate 3000 obs are already in WeeWX Metric
        units. The exceptions are:

        load current (LC) which is in mA (needs to be Amp)
        charge current (CC) which is in mA (needs to be Amp)
        rain since 9am (RS) which is in mm (needs to be cm)

        Look for each of these fields in the parsed data packet and adjust the
        values as necessary. Whilst the parsed data is based on WeeWX field
        names we need to look for Environdata source fields as the user may be
        using a custom field map.
        """

        if parsed_data is not None:
            converter = weewx.units.Converter(weewx.units.MetricUnits)
            result = {}
            for e_field, value in six.iteritems(parsed_data):
                vt = weewx.units.ValueTuple(value,
                                            EnvirondataDriver.r1_map[e_field]['unit'],
                                            EnvirondataDriver.r1_map[e_field]['group'])
                result[e_field] = converter.convert(vt).value
            return result
        else:
            return None

    @staticmethod
    def get_r1_e_field(element):
        """Given an Environdata r1 field name obtain the Environdata field name.

        element: A three way tuple of strings in the
                 format (r1 field name, data, units)
        """

        # iterate over the key, value pairs in the r1 map until we have a
        # match. Remember our 'value' is a dict.
        for key, value in six.iteritems(EnvirondataDriver.r1_map):
            # do we have a match for the element r1 field name
            if element[0] == value['field']:
                # we have a match, but the r1 packet includes two ambiguous
                # field names; 'IW' could be instantaneous wind speed or
                # instantaneous wind direction. To make sure we have the right
                # one we need to check the units.
                if value['field'] == 'IW':
                    # We have an ambiguous field name. Check to see which r1
                    # field we have based on the units and see if our mapped
                    # field has corresponding units. If they do then we have
                    # the right field, if they don't we have the wrong field
                    # and we should continue through the map. Wrap in a
                    # try..except in case element[2] is not a string.
                    try:
                        if 'degs' in element[2].lower() and value['unit'] == 'degree_compass' or \
                                'km' in element[2].lower() and value['unit'] == 'km_per_hour':
                            return key
                        else:
                            continue
                    except AttributeError:
                        # likely element[2] is not a string
                        continue
                else:
                    # any other field is not ambiguous so return the key
                    return key
        return None


# ============================================================================
#                             Utility functions
# ============================================================================

def ip_from_config_opts(opts, stn_dict):
    """Obtain the IP address from station config or command line options.

    Determine the IP address to use given a station config dict and command
    line options. The IP address is chosen as follows:
    - if specified use the IP address from the command line
    - if an IP address was not specified on the command line obtain the IP
      address from the station config dict
    """

    # obtain an IP address from the command line options
    ip_address = opts.ip_address if opts.ip_address else None
    # if we didn't get an IP address check the station config dict
    if ip_address is None:
        # obtain the IP address from the station config dict
        ip_address = stn_dict.get('ip_address')
        if ip_address is not None:
            if weewx.debug >= 1:
                print()
                print("IP address obtained from station config")
        else:
            if weewx.debug >= 1:
                print()
                print("Could not obtain an IP address")
    else:
        if weewx.debug >= 1:
            print()
            print("IP address obtained from command line options")
    return ip_address


def port_from_config_opts(opts, stn_dict):
    """Obtain the port from station config or command line options.

    Determine the port to use given a station config dict and command
    line options. The port is chosen as follows:
    - if specified use the port from the command line
    - if a port was not specified on the command line obtain the port from
      the station config dict
    - if the station config dict does not specify a port use the default
      port number
    """

    # obtain a port number from the command line options
    port = opts.port if opts.port else None
    # if we didn't get a port number check the station config dict
    if port is None:
        # obtain the port number from the station config dict
        port = stn_dict.get('port')
        # if a port number was specified it needs to be an integer not a
        # string so try to do the conversion
        try:
            port = int(port)
        except (TypeError, ValueError):
            # If a TypeError then most likely port somehow ended up being
            # None. If a ValueError then we couldn't convert the port
            # number to an integer. Regardless use the default port number.
            port = DEFAULT_PORT
            if weewx.debug >= 1:
                print("Port number set to default port number")
        else:
            if weewx.debug >= 1:
                print("Port number obtained from station config")
    else:
        if weewx.debug >= 1:
            print("Port number obtained from command line options")
    return port


# To use this driver in standalone mode for testing or development, use one of
# the following commands (depending on your WeeWX install). For setup.py
# installs use:
#
#   $ PYTHONPATH=/home/weewx/bin python -m user.environdata
#
# or for package installs use:
#
#   $ PYTHONPATH=/usr/share/weewx python -m user.environdata
#
# The above commands will display details of available command line options.
#
# Note. Whilst the driver may be run independently of WeeWX the driver still
# requires WeeWX and it's dependencies be installed. Consequently, if
# WeeWX 4.0.0 or later is installed the driver must be run under the same
# Python version as WeeWX uses. This means that on some systems 'python' in the
# above commands may need to be changed to 'python2' or 'python3'.

def main():
    import optparse

    usage = """Usage: python -m user.environdata --help
       python -m user.environdata --version
       python -m user.environdata --test-driver
            [CONFIG_FILE|--config=CONFIG_FILE]  
            [--ip-address=IP_ADDRESS] [--port=PORT]
            [--poll-interval=INTERVAL]
            [--max-tries=MAX_TRIES]
            [--retry-wait=RETRY_WAIT]
            [--debug=0|1|2|3]     
       python -m user.environdata --live-data
            [CONFIG_FILE|--config=CONFIG_FILE]
            [--ip-address=IP_ADDRESS] [--port=PORT]
            [--debug=0|1|2|3]"""

    parser = optparse.OptionParser(usage=usage)
    parser.add_option('--version', dest='version', action='store_true',
                      help='display driver version number')
    parser.add_option('--config', dest='config_path', metavar='CONFIG_FILE',
                      help="Use configuration file CONFIG_FILE.")
    parser.add_option('--debug', dest='debug', type=int,
                      help='How much status to display, 0-3')
    parser.add_option('--live-data', dest='live', action='store_true',
                      help='display live station data')
    parser.add_option('--test-driver', dest='test_driver', action='store_true',
                      metavar='TEST_DRIVER', help='test the Environdata driver')
    parser.add_option('--ip-address', dest='ip_address',
                      help='Station IP address to use')
    parser.add_option('--port', dest='port', type=int,
                      help='Station telnet port to use')
    parser.add_option('--poll-interval', dest='poll_interval', type=int,
                      help='how often to poll the station')
    parser.add_option('--max-tries', dest='max_tries', type=int,
                      help='max number of attempts to contact the station')
    parser.add_option('--retry-wait', dest='retry_wait', type=int,
                      help='how long to wait between attempts to contact the station')
    (opts, args) = parser.parse_args()

    # display driver version number
    if opts.version:
        print("%s driver version: %s" % (DRIVER_NAME, DRIVER_VERSION))
        exit(0)

    # get config_dict to use
    config_path, config_dict = weecfg.read_config(opts.config_path, args)
    print("Using configuration file %s" % config_path)
    stn_dict = config_dict.get('Environdata', {})

    # set weewx.debug as necessary
    if opts.debug is not None:
        _debug = weeutil.weeutil.to_int(opts.debug)
    else:
        _debug = weeutil.weeutil.to_int(config_dict.get('debug', 0))
    weewx.debug = _debug
    # inform the user if the debug level is 'higher' than 0
    if _debug > 0:
        print("debug level is '%d'" % _debug)

    # Now we can set up the user customized logging but we need to handle both
    # v3 and v4 logging. V4 logging is very easy but v3 logging requires us to
    # set up syslog and raise our log level based on weewx.debug
    try:
        # assume v 4 logging
        weeutil.logger.setup('weewx', config_dict)
    except AttributeError:
        # must be v3 logging, so first set the defaults for the system logger
        syslog.openlog('weewx', syslog.LOG_PID | syslog.LOG_CONS)
        # now raise the log level if required
        if weewx.debug > 0:
            syslog.setlogmask(syslog.LOG_UPTO(syslog.LOG_DEBUG))

    # display station live data
    if opts.live:
        print("Not yet implemented.")
        exit(0)

    # test the environdata driver
    if opts.test_driver:
        loginf("Testing Environdata driver...")
        # set the IP address and port in the station config dict
        stn_dict['ip_address'] = ip_from_config_opts(opts, stn_dict)
        stn_dict['port'] = port_from_config_opts(opts, stn_dict)
        if opts.poll_interval:
            stn_dict['poll_interval'] = opts.poll_interval
        if opts.max_tries:
            stn_dict['max_tries'] = opts.max_tries
        if opts.retry_wait:
            stn_dict['retry_wait'] = opts.retry_wait
        # wrap in a try..except in case there is an error
        try:
            # get an EnvirondataDriver object
            driver = EnvirondataDriver(**stn_dict)
            # identify the station being used
            print()
            print("Interrogating %s at %s:%d" % (driver.hardware_name,
                                                 driver.ip_address,
                                                 driver.port))
            print()
            # continuously get loop packets and print them to screen
            for packet in driver.genLoopPackets():
                print(": ".join([weeutil.weeutil.timestamp_to_string(packet['dateTime']),
                                 weeutil.weeutil.to_sorted_string(packet)]))
        except KeyboardInterrupt:
            # we have a keyboard interrupt so shut down
            driver.closePort()
        loginf("Environdata driver testing complete")
        exit(0)


if __name__ == "__main__":
    main()
